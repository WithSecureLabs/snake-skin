export function formatBytes(bytes, decimals = 2) {
  // Pinched from good old SO!!!
   if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

export function formatTags(tags) {
  if (typeof tags !== 'string') {
    return [];
  }
  const delimiters = [":", "-"];  // TODO: Add as setting
  const regex = new RegExp(delimiters.join('|'), 'g');
  return tags.trimLeft().split(/,|;/).filter(t => t !== '').map(t => {
    const parts = t.trimLeft().split(regex);
    if (parts.length > 1) {
      let style = 'is-link';
      if (parts[0] === 'high' || parts[0] === 'danger') {
        style = 'is-danger';
      } else if (parts[0] === 'medium' || parts[0] === 'warning') {
        style = 'is-warning';
      } else if (parts[0] === 'low' || parts[0] === 'success') {
        style = 'is-success';
      }
      return {
        class: style,
        prefix: parts[0],
        value: t.slice(parts[0].length + 1),
      };
    } else {
      return {class: 'is-link', value: t};
    }
  });
}

export function sorted(unordered) {
  const ordered = {};
  Object.keys(unordered).sort().forEach((key) => {
    ordered[key] = unordered[key];
  });
  return ordered;
}

export function toCaps(string, { delimiter } = {}) {
  let delim = ' ';
  if (delimiter) {
    delim = delimiter;
  }
  const words = [];
  string.split(delim).forEach((word) => {
    words.push(word.charAt(0).toUpperCase() + word.slice(1));
  });
  return words.join(' ');
}
